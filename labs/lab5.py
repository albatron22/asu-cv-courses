import marimo

__generated_with = "0.16.0"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    # Л5: Выделение контуров и краев на изображениях

    **CV (Computer Vision)**, или *машинное зрение*, — это область искусственного интеллекта, которая занимается разработкой алгоритмов и методов, позволяющих компьютерам "видеть" и интерпретировать изображения и видео. Основная задача компьютерного зрения — автоматическое извлечение полезной информации из визуальных данных, например, распознавание объектов, определение их местоположения или анализ сцен. Это может включать такие приложения, как автоматизация вождения, распознавание лиц и обработка медицинских изображений.

    **OpenCV (Open Source Computer Vision Library)** — библиотека алгоритмов компьютерного зрения, обработки изображений и численных алгоритмов общего назначения с открытым кодом
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## ☝️ПОРЯДОК ВЫПОЛНЕНИЯ

    ЛР выполняется последователньно. По мере продвижения по работе вы будете получать задания для закрепления прочитанной теории

    ✏️ **ЗАДАНИЕ 1.**
    ✏️ **ЗАДАНИЕ 2.** и т.д.

    Для каждого задания создается отдельный скрипт Python. Всего заданий будет 4. В качестве отчета необходимо предоставить файлы кода для каждого задания. Отчет закреплять на moodle.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 1/ Подготовка среды выполнения
    На данной этапе вам наобходимо подготовить виртуальное окружение и установить все необходимые библиотеки.

    1. Создать и активировать (или только активировать, если ранне создавали) виртуальной окружение `python`.

    Создайте на диске свою раюочую папку. Откройте терминал и перейдите в свою рабочую директорию
    ```
    cd path/to/your/workspace
    ```
    Далее создаем виртуальное окружение с помощью `python-venv`
    ```
    python -m venv env
    ```
    *активируем виртуальное окружение*
    для CMD:
    ```
    env\Scripts\activate
    ```
    для PowerShell
    ```
    env\Scripts\Activate.ps1
    ```
    для bash
    ```
    source env/bin/activate
    ```
    **Примечание.** `env` - это название вашего виртуального окружения, назвать его можете как угодно.

    После этого можем выбрать наш локальный интерпрететор pyhton, нажав на кнопку выше "Select kernel".

    1. Устанавливаем все необходимые библиотеки

    **Примечание.** Библиотеки установятся внутрь вашего виртуального окружения.

    Нам понадобятся `opencv-python`.
    ```
    pip install opencv-python
    ```
    И `marimo` для для просмотра интерактивной лабораторной работы
    ```
    pip install marimo
    ```
    _но вы должны были ее установить уже до открытия этого приложения_
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 2/ Получение видеопотока

    Вы можете использовать три варианта получения видеопотока: **со встроенной или подключенной камере к вашему ноутбуку, из видеофайла или из локальной сети на занятии в аудитории.**

    /// details | Код для случая видеокамеры или видеофайла
    ```python
    import cv2

    # Захватываем видеопоток с веб-камеры
    cap = cv2.VideoCapture(0)
    # или из файла
    # cap = cv2.VideoCapture('video.mp4')
    while True:
        # Читаем кадр с камеры
        ret, frame = cap.read()
        # Отображаем кадр на экране
        cv2.imshow('WebCam', frame)
        # Ожидание 1 миллисекунды на проверку нажатия клавиши 'q'
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Освобождаем ресурсы после завершения работы
    cap.release()
    # Закрываем все окна
    cv2.destroyAllWindows()
    ```
    ///

    Для получения **видеопотока по локальной сети** необходимо создать UDP сокет и подключится к multicast группе. В главном цикле читается байтовый массив по сокету, который преобразуется в jpeg-кадр. Ниже представлен базоый скрипт клиента получения видеопотока:

    /// details | Код клиента
    ```python
    import socket
    import cv2
    import numpy as np

    # Настройки multicast
    MCAST_GRP = '239.1.1.1'
    MCAST_PORT = 5007

    ############### ВМЕСТО cap = cv2.VideoCapture(0) ####################
    #####################################################################
    # Создаем UDP сокет
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Присоединяемся к multicast группе
    sock.bind(('', MCAST_PORT))
    mreq = socket.inet_aton(MCAST_GRP) + socket.inet_aton('0.0.0.0')
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
    #####################################################################

    # Главный цикл
    while True:
    ############### ВМЕСТО ret, frame = cap.read() ######################
    #####################################################################
        # Получаем данные
        data, addr = sock.recvfrom(65536)  # Макс размер UDP пакета

        # Декодируем JPEG в изображение
        nparr = np.frombuffer(data, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    #####################################################################

        if frame is not None:s
            cv2.imshow('Multicast Stream', frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cv2.destroyAllWindows()
    sock.close()
    ```
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 3/ **Методы выделения контуров и краев на изображениях**
    ### 3.1/ **Обнаружение границ**

    Выделение контуров и краев на изображениях – это процесс выявления границ объектов или переходов между различными областями в изображении. Это помогает выделить важные детали и структуры.

    Эта техника имеет множество применений, таких как распознавание образов, сегментация объектов, улучшение качества изображений, медицинская диагностика и другие области. Выделение границ и контуров помогает выделить объекты на изображении, делая их более заметными для последующей обработки.

    Основной принцип выделения границ – это выявление изменений в яркости или цвете пикселей изображения. Граница объекта обычно представляет собой резкое изменение яркости. Для этого используются различные методы, такие как детекция градиента, фильтры или морфологические операции.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    В библиотеке OpenCV для обнаружения границ на изображении применяют функцию `cv2.Canny()` с использованием алгоритма Canny.

    Алгоритм Canny, реализованный в `cv2.Canny()`, представляет собой многоступенчатый процесс для точного выделения границ на изображениях. Первым шагом применяется фильтр Гаусса для снижения уровня шума, который мог бы привести к ложному обнаружению границ. Затем, для определения резких изменений в интенсивности изображения, вычисляются градиенты яркости.

    **Градиент** в данном контексте – это вектор, показывающий направление и скорость изменения яркости пикселей. Он вычисляется как изменение интенсивности в горизонтальном и вертикальном направлениях, и его величина указывает на то, насколько резким является переход яркости. Высокая величина градиента обычно соответствует границе объекта.
    """
    )
    return


@app.cell
def _(mo):
    mo.md(r"""![1](public/image_1.png)""")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""Далее, для уточнения границ и сохранения только значимых пикселей, используется немаксимальное подавление. Этот этап оставляет лишь локальные максимумы градиента вдоль направления этого градиента, тем самым убирая избыточные значения и делая контуры более четкими. На завершающем этапе применяется гистерезисная пороговая обработка с использованием двух пороговых значений: высокого и низкого. Пиксели, величина градиента которых выше верхнего порога, однозначно считаются границами. Пиксели, величина градиента которых находится между двумя порогами, включаются в контур только в том случае, если они связаны с уже определенной границей. Такой подход позволяет избежать разрывов в контурах и более точно определить их границы, отбрасывая слабые и малозначимые переходы.""")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Рассмотрим пример программы, которая использует алгоритм Canny для обнаружения границ на входном изображении с применением порогов гистерезиса 50 и 150 и отображает оригинальное изображение и результат обнаружения границ.

    ```python
    import cv2

    # Захват видеопотока с камеры
    cap = cv2.VideoCapture(0)
    while True:
        # Считывание кадра из видеопотока
        ret, frame = cap.read()
        # Преобразование цветного кадра в оттенки серого
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        # Применение алгоритма Canny
        kontur = cv2.Canny(gray, 50, 150)
        # Отображение оригинального кадра
        cv2.imshow('Original Frame', frame)
        # Отображение измененного кадра
        cv2.imshow('Contour Frame', kontur)
        # Проверка на нажатие клавиши 'q' для выхода из цикла
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Освобождение ресурсов
    cap.release()
    cv2.destroyAllWindows()
    ```

    В представленном коде функция `cv2.Canny(frame, 50, 150)` применяена к каждому кадру `frame` видеопотока. Первое значение называется `threshold1` — параметр представляет собой нижний порог градиента. В данном случае, пиксели, чья величина градиента ниже 50, отбрасываются, так как они считаются шумом или малозначимыми изменениями. Пиксели с градиентом, равным или превышающим 50, становятся кандидатами на часть контура.

    Второе значение называется `threshold2` — параметр представляет собой верхний порог градиента. Пиксели с градиентом выше этого порога будут рассматриваться как часть «сильных» контуров.

    Пиксели с градиентом между 50 и 150 могут стать частью контура, только если они связаны с пикселями, которые уже были идентифицированы как «сильные» границы. Этот подход, известный как гистерезисная пороговая обработка, позволяет более точно выявить границы, подавляя шум и избегая разрывов в контурах.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 1.**
    На практике значения порогов могу варьироваться в зависимости от конкретной задачи. Изменения этих порогов может влиять на количество и интенсивность этих порогов. Проведите эксперимент с целью настройки нижнего и верхнего порога для обнаружения границ только крупных предметов на изображении (мебель, стыки стен и потолка и т.д.)
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ### 3.2/ **Обнаружение контуров**

    Как было сказано выше, функция `cv2.Canny()` используется, чтобы найти места, где цвета на изображении меняются очень резко. Она помогает нам найти контуры объектов, обозначая места, где яркость на изображении изменяется резко. Она не возвращает непосредственно контуры, а просто выделяет места, где объекты заканчиваются или начинаются.

    А вот для создания контуров и работы с ними применяют две функции: `cv2.findContours()` и `cv2.drawContours()`.

    После применения алгоритма Canny с помощью функции `cv2.Canny()`, которая выделяет границы объектов, мы можем воспользоваться функцией `cv2.findContours()` для определения контуров этих объектов. Далее, функция `cv2.drawContours()` позволяет визуализировать найденные контуры, отобразив их непосредственно на изображении. Таким образом, для извлечения и отрисовки контуров на изображении обычно используют эти две функции, `cv2.findContours()` и `cv2.drawContours()`.

    Важно отметить, что использование `cv2.Canny()` не является обязательным шагом перед `cv2.findContours()`. Для нахождения контуров достаточно преобразовать исходное изображение в бинарный формат и уже к этому бинарному изображению применить функцию `cv2.findContours()` и последующую отрисовку `cv2.drawContours()`.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Именно такой пример программы рассмотрен ниже.

    ```python
    import cv2

    # Захватываем видеопоток с первой доступной в системе веб-камеры
    cap = cv2.VideoCapture(0)
    while True:
        # Считываем кадр с веб-камеры
        ret, frame = cap.read()
        # Преобразование цветного изображения в оттенки серого
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        # Бинаризация изображения кадра
        _, binar = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
        # Выделение контуров на изображении кадра
        kontur, _ = cv2.findContours(binar, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        # Отображение контуров на заданном изображении
        im_kontur = cv2.drawContours(frame, kontur, -1, (0, 255, 0), 2)
        # Отображаем исходный кадр
        cv2.imshow('Contours', frame)

        # Ждём нажатия клавиши 'q' для выхода из цикла
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Освобождаем ресурсы
    cap.release()
    cv2.destroyAllWindows()
    ```

    В данной программе каждый кадр преобразуется в оттенки серого, после чего применяется бинаризация, чтобы получить черно-белое изображение. Затем на бинаризованном изображении находятся контуры объектов, используя функцию `cv2.findContours()`. Найденные контуры затем отображаются на исходном цветном кадре с помощью функции `cv2.drawContours()`.

    Функция `cv2.findContours()` вызывается с тремя аргументами: `binar`, `cv2.RETR_EXTERNAL`, `cv2.CHAIN_APPROX_NONE`.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Первый аргумент `binar` – переменная, содержащая бинаризованное изображение, на котором мы хотим найти контуры. В нашем случае это черно-белое изображение кадра, полученное после преобразования в оттенки серого и бинаризации.

    Второй аргумент – режим поиска контуров. В данном случае используется `cv2.RETR_EXTERNAL`, что означает, что функция будет извлекать только внешние контуры, игнорируя внутренние.

    Третий аргумент – метод аппроксимации контуров. Здесь используется `cv2.CHAIN_APPROX_NONE`, который сохраняет все точки контура без сжатия или упрощения.

    Таким образом, эта строка кода ищет внешние контуры на бинаризованном изображении.

    В функции 
    ```
    cv2.drawContours(frame, kontur, -1, (0, 255, 0), 2)
    ```

    - `frame` – это исходное изображение, на котором будут нарисованы контуры. В данном контексте переменная `frame` содержит кадр с веб-камеры, на котором происходит обнаружение контуров;
    - `kontur` – это переменная, хранящая найденные контуры. Эти контуры были определены с помощью `cv2.findContours()` и представляют собой собой массив данных. Каждый внешний элемент этого массива соответствует отдельному контуру, а каждый контур, в свою очередь, является массивом точек (с координатами x и y), описывающих его форму. Таким образом, `kontur` содержит список всех обнаруженных контуров, где каждый контур — это последовательность точек, формирующих его границу;
    - `-1` – это параметр, определяющий индекс контура для отрисовки. Значение `-1` указывает на необходимость отрисовать все найденные контуры. Если вместо `-1` указать `0`, будет отображен первый контур. Аналогично можно указать индекс любого из найденных контуров для его отображения;
    - `(0, 255, 0)` – определяет цвет отрисовки контуров. В данном случае, это зеленый цвет в формате BGR;
    - `2` – задает толщину линии контура, равную 2 пикселям.

    Кроме того, можно укзаать диапазон конутров, которые могут вызывать интерес:
    ```
    cv2.drawContours(frame, kontur[150:200], -1, (0, 255, 0), 2)
    ```
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 2.**
    Напишите программу для выделения и отрисовки конутров объектов, границы которых найдены в предыдущем _задании 1_. Выделите контура разным цветом. Побробуйте перемещать объекты, вероятно вы обнаружите, что цвет контура одного и того же объекта на изображении меняется. В является следствием того, что в динамике индек контура не привязан и объетку. То есть данные методы недостаточны для отслеживания конкретного контура.
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Форма отчета

    Отчет должен представлять собой программный код для всех заданий и скриншоты экрана, демонстрирующие работоспособоность вашего кода. Отчет загрузить на **moodle**
    """
    )
    return


if __name__ == "__main__":
    app.run()
