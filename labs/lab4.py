import marimo

__generated_with = "0.16.0"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    # Л4: Фильтрация изображений

    **CV (Computer Vision)**, или *машинное зрение*, — это область искусственного интеллекта, которая занимается разработкой алгоритмов и методов, позволяющих компьютерам "видеть" и интерпретировать изображения и видео. Основная задача компьютерного зрения — автоматическое извлечение полезной информации из визуальных данных, например, распознавание объектов, определение их местоположения или анализ сцен. Это может включать такие приложения, как автоматизация вождения, распознавание лиц и обработка медицинских изображений.

    **OpenCV (Open Source Computer Vision Library)** — библиотека алгоритмов компьютерного зрения, обработки изображений и численных алгоритмов общего назначения с открытым кодом
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## ☝️ПОРЯДОК ВЫПОЛНЕНИЯ

    ЛР выполняется последователньно. По мере продвижения по работе вы будете получать задания для закрепления прочитанной теории

    ✏️ **ЗАДАНИЕ 1.**
    ✏️ **ЗАДАНИЕ 2.** и т.д.

    Для каждого задания создается отдельный скрипт Python. Всего заданий будет 4. В качестве отчета необходимо предоставить файлы кода для каждого задания. Отчет закреплять на moodle.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 1/ Подготовка среды выполнения
    На данной этапе вам наобходимо подготовить виртуальное окружение и установить все необходимые библиотеки.

    1. Создать и активировать (или только активировать, если ранне создавали) виртуальной окружение `python`.

    Создайте на диске свою раюочую папку. Откройте терминал и перейдите в свою рабочую директорию
    ```
    cd path/to/your/workspace
    ```
    Далее создаем виртуальное окружение с помощью `python-venv`
    ```
    python -m venv env
    ```
    *активируем виртуальное окружение*
    для CMD:
    ```
    env\Scripts\activate
    ```
    для PowerShell
    ```
    env\Scripts\Activate.ps1
    ```
    для bash
    ```
    source env/bin/activate
    ```
    **Примечание.** `env` - это название вашего виртуального окружения, назвать его можете как угодно.

    После этого можем выбрать наш локальный интерпрететор pyhton, нажав на кнопку выше "Select kernel".

    1. Устанавливаем все необходимые библиотеки

    **Примечание.** Библиотеки установятся внутрь вашего виртуального окружения.

    Нам понадобятся `opencv-python`.
    ```
    pip install opencv-python
    ```
    И `marimo` для для просмотра интерактивной лабораторной работы
    ```
    pip install marimo
    ```
    _но вы должны были ее установить уже до открытия этого приложения_
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 2/ Получение видеопотока

    Вы можете использовать три варианта получения видеопотока: **со встроенной или подключенной камере к вашему ноутбуку, из видеофайла или из локальной сети на занятии в аудитории.**

    /// details | Код для случая видеокамеры или видеофайла
    ```python
    import cv2

    # Захватываем видеопоток с веб-камеры
    cap = cv2.VideoCapture(0)
    # или из файла
    # cap = cv2.VideoCapture('video.mp4')
    while True:
        # Читаем кадр с камеры
        ret, frame = cap.read()
        # Отображаем кадр на экране
        cv2.imshow('WebCam', frame)
        # Ожидание 1 миллисекунды на проверку нажатия клавиши 'q'
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Освобождаем ресурсы после завершения работы
    cap.release()
    # Закрываем все окна
    cv2.destroyAllWindows()
    ```
    ///

    Для получения **видеопотока по локальной сети** необходимо создать UDP сокет и подключится к multicast группе. В главном цикле читается байтовый массив по сокету, который преобразуется в jpeg-кадр. Ниже представлен базоый скрипт клиента получения видеопотока:

    /// details | Код клиента
    ```python
    import socket
    import cv2
    import numpy as np

    # Настройки multicast
    MCAST_GRP = '239.1.1.1'
    MCAST_PORT = 5007

    ############### ВМЕСТО cap = cv2.VideoCapture(0) ####################
    #####################################################################
    # Создаем UDP сокет
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Присоединяемся к multicast группе
    sock.bind(('', MCAST_PORT))
    mreq = socket.inet_aton(MCAST_GRP) + socket.inet_aton('0.0.0.0')
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
    #####################################################################

    # Главный цикл
    while True:
    ############### ВМЕСТО ret, frame = cap.read() ######################
    #####################################################################
        # Получаем данные
        data, addr = sock.recvfrom(65536)  # Макс размер UDP пакета

        # Декодируем JPEG в изображение
        nparr = np.frombuffer(data, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    #####################################################################

        if frame is not None:s
            cv2.imshow('Multicast Stream', frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cv2.destroyAllWindows()
    sock.close()
    ```
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 3/ **Методы обработки изображений и фильтрация**
    ### 3.1/ **Бинаризация и пороговая обработка**

    **Бинаризация** — это техника обработки изображений, при которой каждый пиксель изображения преобразуется в белый или чёрный (или в любые другие две пары цветов) на основе заданного порога. Пороговая обработка используется для преобразования изображения в бинарное (двухцветное) изображение.

    Бинаризация полезна при выделении объектов или областей интереса на изображении, а также при упрощении дальнейшего анализа изображений. Она позволяет превратить сложные изображения в бинарные, где объекты выделены контуром.

    Принцип бинаризации основан на установлении порога интенсивности для каждого пикселя. Если значение пикселя превышает порог, то он становится белым, в противном случае — чёрным. Таким образом, изображение разделяется на две категории: объекты интереса (белые) и фон (чёрный).

    Важно понимать, что бинарное изображение — это не обязательно чёрно-белое. Это может быть сине-черное или красно-жёлтое изображения.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Применение метода бинаризации статического изображения или видеокадра, принятого с веб-камеры, осуществляется функцией `cv2.threshold()`.

    Данная функция библиотеки OpenCV используется для преобразования изображения в изображение с бинарными (двоичными) значениями (чёрно-белое изображение), основываясь на пороговом значении.

    ```python
    import cv2

    # Захват видеопотока с камеры
    cap = cv2.VideoCapture(0)

    while True:
        # Считывание кадра из видеопотока
        ret, frame = cap.read()

        # Бинаризация изображения в кадре
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        _, frame1 = cv2.threshold(gray_frame, 127, 255, cv2.THRESH_BINARY)

        # Отображение оригинального кадра
        cv2.imshow('Original Frame', frame)
        # Отображение модифицированного кадра
        cv2.imshow('Modified Frame', _frame1)

        # Проверка на нажатие клавиши 'q' для выхода из цикла
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Освобождение ресурсов
    cap.release()
    cv2.destroyAllWindows()
    ```

    Результат выполнения рассмотренной программы представлен на рис. 3.11.

    В программном коде строка `gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)` преобразовывает цветовое пространство из области BGR в область GRAY и только потом происходит непосредственно бинаризация изображения строкой `_frame1 = cv2.threshold(gray_frame, 127, 255, cv2.THRESH_BINARY`. В случае с бинаризацией эти две строки всегда должны работать вместе. Рассмотрим коэффициенты этих функций.

    `gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)` — эту функцию мы ранее рассматривали и здесь мы лишь напомним, что она служит для получения промежуточного изображения в пространстве серых цветов. Поскольку функция `cv2.threshold()` использует в качестве аргумента изображение в тонах серого цвета.

    `frame1 = cv2.threshold(gray_frame, 127, 255, cv2.THRESH_BINARY)`. Здесь мы используем функцию `cv2.threshold()` для бинаризации изображения в оттенках серого (`gray_frame`). Функция принимает несколько параметров: `gray_frame` — исходное изображение в оттенках серого.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    `thresh=127` — пороговое значение, которое используется для классификации пикселей. Если интенсивность пикселя выше порогового значения, он будет установлен в максимальное значение (в данном случае, 255); в противном случае, он будет установлен в минимальное значение (в данном случае, 0).

    `maxval=255` — максимальное значение пикселя, которое будет установлено для пикселей с интенсивностью выше порогового значения.

    `type=cv2.THRESH_BINARY` — этот флаг указывает на тип бинаризации. В данном случае, если интенсивность пикселя больше порогового значения, то она будет установлена в максимальное значение (255), в противном случае — в минимальное значение (0). Другие значения этого флага, а также полный обзор функции `cv2.threshold()` рассмотрен в Приложении данной книги.

    Бинаризация и пороговая обработка изображений имеет важно место во многих областях знаний:

    1. **Выделение объектов на медицинских изображениях**: бинаризация применяется для выделения тканей или определения контуров на медицинских снимках, что может быть важным для диагностики.

    2. **Распознавание текста на изображениях**: в области компьютерного зрения, бинаризация часто используется для выделения текста на изображениях, что упрощает его распознавание.

    3. **Обработка изображений в системах безопасности**: на транспортных средствах, бинаризация может применяться для выделения объектов интереса, таких как номера автомобилей, на изображениях с видеокамер наблюдения.

    4. **Распознавание номерных знаков**: бинаризация может быть применена для выделения номерных знаков на изображениях с камер видеонаблюдения на дорогах. Это упрощает последующий процесс распознавания номеров транспортных средств.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 1.**
    Допустим мы хотим реализовать задачу распознавания и локализацию **Aruco маркеров**. Для этого необходимо совершить преодобработку изображения и выделить маркер с поомщью операции бинаризации. Это делается с целью улучшить контрастность Aruco маркера. Напишите программу и так подберите пороговое значение бинаризации, чтобы в видеопотоке четко выделяля маркер (желательно, чтобы не остальные объекты и фон остался ненаблюдаемый)
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 4/. **Фильтрация**

    ### 4.1/ **Основные термины и явления фильтрации**

    В контексте обработки изображений термин **«фильтр»** обозначает математическую операцию, выполняемую с целью изменения характеристик изображения, улучшения его качества или извлечения определенной информации. Эта операция реализуется посредством ядра (маски).

    **Ядро (маска)** — это двумерная матрица числовых значений, представляющих весовые коэффициенты. Они определяют, как именно фильтр будет воздействовать на изображение в процессе свертки.

    **Свертка** — это математическая операция, лежащая в основе фильтрации. Ядро «скользит» по изображению, и для каждого его положения вычисляется новое значение пикселя. Это происходит путем умножения значений пикселей изображения, на которые наложено ядро, на соответствующие весовые коэффициенты ядра. Затем полученные произведения суммируются, и результат становится новым значением центрального пикселя.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    **Размытие (сглаживание)** — это фильтрация, направленная на уменьшение резкости деталей и шума на изображении. Обычно для этого используются ядра, которые усредняют значения пикселей, например, усредняющие или гауссовы ядра.

    _Применение различной степени размытости (с ядром 3х3 и 7х7)_
    ![](public\image.png)
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    **Резкость (усиление контраста)** — это фильтрация, которая увеличивает выразительность краев и мелких деталей. Для этой цели часто используются ядра, основанные на операциях дифференцирования, такие как оператор Лапласа.

    _Применение фильтра резкости_
    ![](public\image1.png)
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    **Обнаружение границ** — это фильтрация, предназначенная для выявления резких переходов яркости в изображении, которые соответствуют контурам объектов. В этом случае применяются ядра, которые чувствительны к градиентам, например, ядра Собеля или Шарра.

    _Пример фильтра обнаружения границ_
    ![](public\image3.png)
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ### 4.2/ **Практическое применение фильтров**

    **Фильтр Гаусса** — это математический алгоритм, широко применяемый в обработке изображений и сигналов. Он базируется на распределении Гаусса (нормальном распределении) и используется для сглаживания изображений, устранения шумов и выделения ключевых особенностей.

    Фильтр Гаусса эффективно сглаживает изображение, уменьшая влияние шумовых пикселей, не искажая слишком сильно детали изображения. В этом случае, благодаря своей характеристике гладкости и способности уменьшать резкие скачки яркости, фильтр Гаусса позволит сгладить случайные, внезапные изменения значений пикселей. В результате изображение станет менее «зернистым» и более однородным.

    Рассмотрим пример использования функции `cv2.GaussianBlur()` фильтра Гаусса на простом программном коде.

    ```python
    import cv2

    # Загрузка изображения
    image_path = "image.jpg"  # путь к исходному изображению
    output_path = "filtered_image.jpg"  # путь для сохранения результата
    kernel_size = (15, 15)
    sigma_x = 0
    image = cv2.imread(image_path)

    # Применение фильтра Гаусса
    blurred_image = cv2.GaussianBlur(image, kernel_size, sigma_x)

    # Сохранение результата
    cv2.imwrite(output_path, blurred_image)
    ```
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 2.**
    Адаптируйте этот алгоритм к видепотоку. Подберите различные размеры ядра и параметра `sigma_x` и оцените результат
    ///
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    **Билатеральный фильтр** (Bilateral Filter) — это метод фильтрации изображений, который используется для сглаживания изображений, уменьшения шума, но при этом сохраняет ребра и грани. Этот фильтр применяется в обработке изображений с целью улучшения их визуального восприятия, сохранения деталей и устранения шума.

    Билатеральный фильтр учитывает, как пространственные (геометрические) различия между пикселями, так и яркостные различия. Таким образом, он предназначен для сохранения ребер и граней, учитывая одновременно пространственные и яркостные характеристики изображения.
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    Рассмотрим пример применения функции `cv2.bilateralFilter()` билатерального фильтра на простом программном коде.

    ```python
    import cv2

    # Загрузка изображения
    input_image_path = "image.jpg"  # путь к исходному изображению
    output_image_path = "filtered_image.jpg"  # путь для сохранения результата

    # Параметры билатерального фильтра
    d = 20
    sigma_color = 100
    sigma_space = 120

    image = cv2.imread(input_image_path)

    # Применение билатерального фильтра
    filtered_image = cv2.bilateralFilter(image, d, sigma_color, sigma_space)

    # Сохранение результата
    cv2.imwrite(output_image_path, filtered_image)
    ```

    Для корректной работы билатерального фильтра необходимо настроить три параметра:

    **d** — диаметр окрестности каждого пикселя. Этот параметр определяет, какие пиксели включаются в окрестность каждого пикселя при вычислении весов. Значение `d = 20` означает, что для каждого пикселя будут рассматриваться пиксели, находящиеся в радиусе 10 пикселей от него (диаметр равен 2 × радиус). Чем больше значение `d`, тем больше соседних пикселей будет участвовать в фильтрации, и тем сильнее будет эффект размытия. Однако слишком большое значение может привести к потере деталей, а слишком маленькое не даст желаемого эффекта сглаживания. Значение 20 является достаточно большим и может приводить к заметному сглаживанию.

    **sigma_color** — стандартное отклонение по цвету. Этот параметр контролирует, насколько различия в яркости влияют на веса. Большее значение сглаживает изображение больше. Более высокие значения `sigma_color` означают, что пиксели с более значительными различиями в цвете будут считаться «похожими» и будут участвовать в сглаживании. Если `sigma_color` слишком мало, то фильтр будет больше ориентироваться на различия в цвете, и сглаживание может быть более «тонким» и не будет затрагивать границы объектов. При `sigma_color = 100` фильтр будет более толерантен к различиям в цвете, что приведёт к более сильному сглаживанию, но с сохранением границ, так как их перепады яркости, как правило, значительно выше.

    **sigma_space** — стандартное отклонение по координатам. Этот параметр определяет, насколько пространственные различия влияют на веса. Чем больше значение `sigma_space`, тем дальше расположенные пиксели будут влиять на сглаживание. Параметр `sigma_space` контролирует пространственное размытие, поэтому, при увеличении значения, фильтр будет применять большее размытие с сохранением границ. Значение `sigma_space = 120` в данном случае приведёт к заметному размытию с сохранением границ.
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 3.**
    Адаптируйте код применения билатерального фильтра к видеопотоку. Исследуйте самостоятельно влияние параметров этого фильтра на конечное изображения (меняем параметры и смотрим что получается). Попробуйте добится повышения качества изображения с вашей web-камеры
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Форма отчета

    Отчет должен представлять собой программный код для всех заданий и скриншоты экрана, демонстрирующие работоспособоность вашего кода. Отчет загрузить на **moodle**
    """
    )
    return


if __name__ == "__main__":
    app.run()
