import marimo

__generated_with = "0.16.0"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    # Л2: Методы обработки изображений. Модели цветовых пространств

    **CV (Computer Vision)**, или *машинное зрение*, — это область искусственного интеллекта, которая занимается разработкой алгоритмов и методов, позволяющих компьютерам "видеть" и интерпретировать изображения и видео. Основная задача компьютерного зрения — автоматическое извлечение полезной информации из визуальных данных, например, распознавание объектов, определение их местоположения или анализ сцен. Это может включать такие приложения, как автоматизация вождения, распознавание лиц и обработка медицинских изображений.

    **OpenCV (Open Source Computer Vision Library)** — библиотека алгоритмов компьютерного зрения, обработки изображений и численных алгоритмов общего назначения с открытым кодом
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## ☝️ПОРЯДОК ВЫПОЛНЕНИЯ

    ЛР выполняется последователньно. По мере продвижения по работе вы будете получать задания для закрепления прочитанной теории

    ✏️ **ЗАДАНИЕ 1.**
    ✏️ **ЗАДАНИЕ 2.** и т.д.

    Для каждого задания создается отдельный скрипт Python. Всего заданий будет 4. В качестве отчета необходимо предоставить файлы кода для каждого задания. Отчет закреплять на moodle.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 1/ Подготовка среды выполнения
    На данной этапе вам наобходимо подготовить виртуальное окружение и установить все необходимые библиотеки.

    1. Создать и активировать (или только активировать, если ранне создавали) виртуальной окружение `python`.

    Создайте на диске свою раюочую папку. Откройте терминал и перейдите в свою рабочую директорию
    ```
    cd path/to/your/workspace
    ```
    Далее создаем виртуальное окружение с помощью `python-venv`
    ```
    python -m venv env
    ```
    *активируем виртуальное окружение*
    для CMD:
    ```
    env\Scripts\activate
    ```
    для PowerShell
    ```
    env\Scripts\Activate.ps1
    ```
    для bash
    ```
    source env/bin/activate
    ```
    **Примечание.** `env` - это название вашего виртуального окружения, назвать его можете как угодно.

    После этого можем выбрать наш локальный интерпрететор pyhton, нажав на кнопку выше "Select kernel".

    1. Устанавливаем все необходимые библиотеки

    **Примечание.** Библиотеки установятся внутрь вашего виртуального окружения.

    Нам понадобятся opencv-python.
    ```
    pip install opencv-python
    ```
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ## 2/ Получение видеопотока

    Вы можете использовать три варианта получения видеопотока: **со встроенной или подключенной камере к вашему ноутбуку, из видеофайла или из локальной сети на занятии в аудитории.**

    /// details | Код для случая видеокамеры или видеофайла
    ```python
    import cv2

    # Захватываем видеопоток с веб-камеры
    cap = cv2.VideoCapture(0)
    # или из файла
    # cap = cv2.VideoCapture('video.mp4')
    while True:
        # Читаем кадр с камеры
        ret, frame = cap.read()
        # Отображаем кадр на экране
        cv2.imshow('WebCam', frame)
        # Ожидание 1 миллисекунды на проверку нажатия клавиши 'q'
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Освобождаем ресурсы после завершения работы
    cap.release()
    # Закрываем все окна
    cv2.destroyAllWindows()
    ```
    ///

    Для получения **видеопотока по локальной сети** необходимо создать UDP сокет и подключится к multicast группе. В главном цикле читается байтовый массив по сокету, который преобразуется в jpeg-кадр. Ниже представлен базоый скрипт клиента получения видеопотока:

    /// details | Код клиента
    ```python
    import socket
    import cv2
    import numpy as np

    # Настройки multicast
    MCAST_GRP = '239.1.1.1'
    MCAST_PORT = 5007

    ############### ВМЕСТО cap = cv2.VideoCapture(0) ####################
    #####################################################################
    # Создаем UDP сокет
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Присоединяемся к multicast группе
    sock.bind(('', MCAST_PORT))
    mreq = socket.inet_aton(MCAST_GRP) + socket.inet_aton('0.0.0.0')
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
    #####################################################################

    # Главный цикл
    while True:
    ############### ВМЕСТО ret, frame = cap.read() ######################
    #####################################################################
        # Получаем данные
        data, addr = sock.recvfrom(65536)  # Макс размер UDP пакета

        # Декодируем JPEG в изображение
        nparr = np.frombuffer(data, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    #####################################################################

        if frame is not None:s
            cv2.imshow('Multicast Stream', frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cv2.destroyAllWindows()
    sock.close()
    ```
    ///
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ## 3/ **Методы обработки изображений**
    ### 3.1/ **Преобразование между цветовыми пространствами**

    ![image](public\color_models.png)

    Преобразование между цветовыми пространствами в компьютерном зрении - это изменение представления цветов пикселей из одной системы в другую. Существуют множество различных цветовых пространст. Ниже приведены некоторые из наиболее распространенных.

    **RGB (Red, Green, Blue)** – одно из самых широко используемых цветовых пространств в компьютерной графике и фотографии. Каждый цвет представлен комбинацией трех основных цветов: красного, зеленого и синего. Максимальные значения каждого цвета обычно равны 255.

    Прямой аналогией получения различных оттенков в этом цветовом пространстве является, например, смешивания масляных красок.

    RGB используется в основном для отображения цветов на электронных устройствах, таких как мониторы компьютеров, телевизоры и смартфоны.

    **CMYK (Cyan, Magenta, Yellow, Key/Black)** используется в печати и изображениях. Он основан на комбинации четырех основных цветов: голубого (cyan), пурпурного (magenta), желтого (yellow) и черного (key/black). Это цветовое пространство позволяет точнее представлять цвета, которые можно воспроизвести на печатной машине. Однако, CMYK не может отобразить весь спектр цветов, доступный в RGB. Перевод из RGB в CMYK часто приводит к потере точности цветопередачи.

    CMYK преимущественно используется в полиграфии для печати книг, журналов, рекламной продукции, упаковки и широкоформатных материалов, обеспечивая точное воспроизведение цветов на печатном оборудовании.


    **HSV (Hue, Saturation, Value)** представляет цвета с помощью трех компонентов: оттенок (hue), насыщенность (saturation) и значение (value). Он предоставляет удобный способ управления цветом, особенно для графического дизайна.


    **LAB (CIELAB)** – это цветовая модель, которая разработана для описания всего видимого спектра цветов. Она была разработана Международной комиссией по освещению (CIE) в 1976 году.

    Цветовое пространство LAB разделяет цвет на светлоту и две цветовые оси: (зелёный – красный) и (синий – жёлтый). Это пространство более пригодно для восприятия человеческим глазом и широко используется в приложениях, связанных с визуальным восприятием.


    LAB основано на принципах цветового восприятия человеческого глаза, что делает его более естественным для восприятия человеком. Он учитывает особенности восприятия яркости, контраста и насыщенности, что делает его более соответствующим тому, как люди видят и воспринимают цвета.

    Цветовое пространство LAB используется в профессиональной обработке изображений, цветокоррекции и профилировании, где требуется высокая точность цветопередачи и независимость от устройства вывода. Его применяют в фотопечати, программном обеспечении для управления цветом и в системах контроля качества цветовоспроизведения.


    Цветовое пространство **BGR (Blue, Green, Red)** используется в компьютерной графике и обработке изображений. Оно представляет собой способ организации цветовой информации, где каждый пиксель изображения определяется тремя компонентами: синим (Blue), зеленым (Green) и красным (Red).

    BGR преимущественно используется в компьютерной графике и обработке изображений, особенно в программировании и разработке графических приложений. Это цветовое пространство часто встречается в работе с изображениями в формате BGR, который является одним из стандартных форматов хранения изображений в компьютерных системах. Он также широко применяется в библиотеках и инструментах для обработки изображений, таких как **OpenCV** в языке программирования **Python**.

    Технический аспект заключается в том, что многие камеры и библиотеки обработки изображений в настоящее время продолжают использовать **BGR**, чтобы сохранять совместимость со старым программным обеспечением и форматами данных. В **OpenCV** BGR также используется по умолчанию при чтении изображений с помощью функций библиотеки.

    /// attention | Важно ☝️
    Надо помнить о порядке цветов (**BGR**), когда вы работаете с изображениями в **OpenCV**, чтобы избежать недопонимания при обработке и отображении цветовых данных.
    ///
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    OpenCV предоставляет функцию `cv2.cvtColor()`, которая используется для преобразования цветового пространства изображения. Основным аргументом данной функции является код цветового пространства, который может выглядеть по-разному в зависимости от необходимости преобразования в то или иное цветовое пространство. Вот некоторые примеры, которые применяются наиболее часто в компьютерном зрении:

    - `cv2.COLOR_BGR2GRAY`: преобразование из BGR в оттенки серого.  
    - `cv2.COLOR_BGR2RGB`: преобразование из BGR в RGB.  
    - `cv2.COLOR_BGR2HSV`: преобразование из BGR в HSV.  
    - `cv2.COLOR_BGR2LAB`: преобразование из BGR в LAB.  
    - `cv2.COLOR_BGR2YUV`: преобразование из BGR в YUV.  
    - `cv2.COLOR_BGR2HLS`: преобразование из BGR в HLS.  
    - `cv2.COLOR_BGR2XYZ`: преобразование из BGR в XYZ.  
    - `cv2.COLOR_BGR2LUV`: преобразование из BGR в LUV.  
    - `cv2.COLOR_BGR2YCrCb`: преобразование из BGR в YCrCb.  
    - `cv2.COLOR_BGR2HSV_FULL`: полная версия преобразования из BGR в HSV.  
    - `cv2.COLOR_BGR2HLS_FULL`: полная версия преобразования из BGR в HLS.  
    - `cv2.COLOR_BGR2YUV_I420`: преобразование из BGR в YUV I420.  
    - `cv2.COLOR_BGR2YUV_YV12`: преобразование из BGR в YUV YV12.
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    Рассмотрим преобразование видеокадров функцией `cv2.cvtColor()` в из оригинального BGR в:

    * оттенки серого (GRAY)
    * HSV
    * LAB

    Выведем все 4 изображения в отдельные окна. Ниже представлен код для встраивания в главный цикл

    ```python
    ret, frame = cap.read()

    gr_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lab_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2LAB)

    # Отображаем кадры на экране
    cv2.imshow("Original", frame)
    cv2.imshow("Gray", gr_frame)
    cv2.imshow("HSV", hsv_frame)
    cv2.imshow("LAB", lab_frame)
    ```
    /// attention | Обратите внимание
    Выбор подходящего цветового пространства зависит от конкретной задачи. Например, пространство **HSV** часто используется для работы с цветом, а пространство **LAB** может быть полезным для выделения объектов на изображении. 

    Преобразование цветового пространства используется на этапе промежуточной обработки изображения. Для вывода на экран обработанного изображения следует обратно привести его к исходному BGR пространству:
    ```python
    # Возврат к BGR
    frame1 = cv2.cvtColor(frame_processed, cv2.COLOR_HSV2BGR)
    ```
    ///
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 1.**
    Необходимо провести цветокоррекцию изображения. В первом случае повысить насыщенность цвета на 20%, в втором - понизить яркость изображения на 30%. Напишите код для вывода трех видеоизображений - оригинального и двух с цветокоррекцией.

    _Рекомендации к выполнению задания._ В зависимости от задачи, может быть удобна та или иная **модель цветового пространства**. Выясните на основе теории выше как модель (исходная BGR, HSV или LAB) будет наиболее подходящей для этой задачи.

    _Примечание._ Вам пондобится осуществить доступ к пикселям кадра (фрейма `frame`). Кадр представляет собой трехмерный массив (для BGR, HSV и LAB), двумерный для GRAY. Первый два индекса массива определяют положение пикселя, третий - канал:

    **Для BGR:** `0` - Blue [0..255], `1` - Green [0..255], `2` - Red [0..255]. 

    **Для HSV:** `0` - оттенок (hue) [0..360], `1` - насыщенность (saturation) [0..100%] и `2` - значение (value) [0..100%]. Фактически в OpenCV эти значения имеют тип uint8, поэтому их следует масштабировать к диапазону 0..255

    Например:
    ```python
    frame[:, :, 1] = 255 # задать канал Green максимальной интенсивностью (для BGR)
    frame[:, :, 2] = 20 # в % - сделать цвета более темными (для HSV)
    ```
    ///
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ### 3.2/ **Фильтрация цветов и цветовая сегментация**

    Этот этап обработки изображения позволяет выделять объекты и структуры на изображении, основываясь на их цветовых харакетристиках.


    Фильтрация цветов направлена на выделение или подавлении определнных цветов на изображении (кадре). Это может быть полезным, когда интересующие нас объекты обладают характерными цветовыми свойствами. Может применятся в распознавании медицинских снимков, дорожных знаков и светофоров в беспилотном транспорте и др. Ниже приведены пример применение фильтрации и сегментации в разных отраслях.
    ![](public\segmentation.png)
    """
    )
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    Наиболее распространенными методами фильтрации цветов являются: фильтрация по порогу и морфологические операции.

    **Фильтрация по порогу (Thresholding).** Этот метод заключается в установке порогового значения для каждого цветового канала. Пиксели, чьи значения цветов находятся выше порога, считаются интересующими, тогда как остальные подавляются.

    **Морфологические операции.** Применение операций, таких как расширение и сужение, для выделения или уменьшения объектов на основе их цветовых характеристик. Это помогает улучшить контуры объектов и убрать нежелательные детали.

    Ниже приведен пример кода для выделения объектов зеленого цвета из видеопотока. Для этого применяются функции `cv2.inRange()` и `cv2.bitwise_and()`.

    ```python
    import cv2
    import numpy as np

    cap = cv2.VideoCapture(0)
    # Определение диапазона зеленого цвета в пространстве HSV
    lower_green = np.array([40, 40, 40])
    upper_green = np.array([148, 100, 200])

    while True:
        ret, frame = cap.read()  # Чтение кадра из видеопотока
        # Преобразование кадра в пространство цветов HSV
        hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # Маска для выделения объектов в заданном диапазоне цветов
        mask = cv2.inRange(hsv_frame, lower_green, upper_green)
        # Применение маски к оригинальному кадру
        result = cv2.bitwise_and(frame, frame, mask=mask)
        # Отображение оригинального кадра
        cv2.imshow('Original', frame)
        # Отображение обработанного кадра
        cv2.imshow('Green', result)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()
    ```

    Здесь определяем диапазон для зеленого цвета в пространстве BGR
    ```python
    lower_limit = np.array([40, 40, 40])
    upper_limit = np.array([80, 255, 150])
    ```

    Как правило даный диапазон подбирается экспериментально
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 2.**
    1. Напишите программу для выделения всех красных или всех синих объектов
    2. Необходимо написать прграмму для фильтрации подсвеченных объектов или объектов с повышенной яркостью.

    _Примечание_. Для второго подзадания используете цветовое пространство HSV
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Форма отчета

    Отчет должен представлять собой программный код для всех заданий и скриншоты экрана, демонстрирующие работоспособоность вашего кода. Отчет загрузить на **moodle**
    """
    )
    return


if __name__ == "__main__":
    app.run()
