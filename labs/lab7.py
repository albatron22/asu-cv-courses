import marimo

__generated_with = "0.16.0"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell
def _(mo):
    mo.md(
        r"""
    # Л7: Фильтр Калмана для отслеживания движущихся объектов в OpenCV

    **CV (Computer Vision)**, или *машинное зрение*, — это область искусственного интеллекта, которая занимается разработкой алгоритмов и методов, позволяющих компьютерам "видеть" и интерпретировать изображения и видео. Основная задача компьютерного зрения — автоматическое извлечение полезной информации из визуальных данных, например, распознавание объектов, определение их местоположения или анализ сцен. Это может включать такие приложения, как автоматизация вождения, распознавание лиц и обработка медицинских изображений.

    **OpenCV (Open Source Computer Vision Library)** — библиотека алгоритмов компьютерного зрения, обработки изображений и численных алгоритмов общего назначения с открытым кодом

    **Фильтр Калмана** — это эффективный рекурсивный алгоритм для оценки вектора состояния динамической системы на основе ряда неполных и зашумлённых измерений.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## ☝️ПОРЯДОК ВЫПОЛНЕНИЯ

    ЛР выполняется последователньно. По мере продвижения по работе вы будете получать задания для закрепления прочитанной теории

    ✏️ **ЗАДАНИЕ 1.**
    ✏️ **ЗАДАНИЕ 2.** и т.д.

    Для каждого задания создается отдельный скрипт Python. Всего заданий будет 4. В качестве отчета необходимо предоставить файлы кода для каждого задания. Отчет закреплять на moodle.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 1/ Подготовка среды выполнения
    На данной этапе вам наобходимо подготовить виртуальное окружение и установить все необходимые библиотеки.

    1. Создать и активировать (или только активировать, если ранне создавали) виртуальной окружение `python`.

    Создайте на диске свою раюочую папку. Откройте терминал и перейдите в свою рабочую директорию
    ```
    cd path/to/your/workspace
    ```
    Далее создаем виртуальное окружение с помощью `python-venv`
    ```
    python -m venv env
    ```
    *активируем виртуальное окружение*
    для CMD:
    ```
    env\Scripts\activate
    ```
    для PowerShell
    ```
    env\Scripts\Activate.ps1
    ```
    для bash
    ```
    source env/bin/activate
    ```
    **Примечание.** `env` - это название вашего виртуального окружения, назвать его можете как угодно.

    После этого можем выбрать наш локальный интерпрететор pyhton, нажав на кнопку выше "Select kernel".

    1. Устанавливаем все необходимые библиотеки

    **Примечание.** Библиотеки установятся внутрь вашего виртуального окружения.

    Нам понадобятся `opencv-python`.
    ```
    pip install opencv-python
    ```
    И `marimo` для для просмотра интерактивной лабораторной работы
    ```
    pip install marimo
    ```
    _но вы должны были ее установить уже до открытия этого приложения_
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 2/ Получение видеопотока

    Вы можете использовать три варианта получения видеопотока: **со встроенной или подключенной камере к вашему ноутбуку, из видеофайла или из локальной сети на занятии в аудитории.**

    /// details | Код для случая видеокамеры или видеофайла
    ```python
    import cv2

    # Захватываем видеопоток с веб-камеры
    cap = cv2.VideoCapture(0)
    # или из файла
    # cap = cv2.VideoCapture('video.mp4')
    while True:
        # Читаем кадр с камеры
        ret, frame = cap.read()
        # Отображаем кадр на экране
        cv2.imshow('WebCam', frame)
        # Ожидание 1 миллисекунды на проверку нажатия клавиши 'q'
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Освобождаем ресурсы после завершения работы
    cap.release()
    # Закрываем все окна
    cv2.destroyAllWindows()
    ```
    ///

    Для получения **видеопотока по локальной сети** необходимо создать UDP сокет и подключится к multicast группе. В главном цикле читается байтовый массив по сокету, который преобразуется в jpeg-кадр. Ниже представлен базоый скрипт клиента получения видеопотока:

    /// details | Код клиента
    ```python
    import socket
    import cv2
    import numpy as np

    # Настройки multicast
    MCAST_GRP = '239.1.1.1'
    MCAST_PORT = 5007

    ############### ВМЕСТО cap = cv2.VideoCapture(0) ####################
    #####################################################################
    # Создаем UDP сокет
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Присоединяемся к multicast группе
    sock.bind(('', MCAST_PORT))
    mreq = socket.inet_aton(MCAST_GRP) + socket.inet_aton('0.0.0.0')
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
    #####################################################################

    # Главный цикл
    while True:
    ############### ВМЕСТО ret, frame = cap.read() ######################
    #####################################################################
        # Получаем данные
        data, addr = sock.recvfrom(65536)  # Макс размер UDP пакета

        # Декодируем JPEG в изображение
        nparr = np.frombuffer(data, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    #####################################################################

        if frame is not None:s
            cv2.imshow('Multicast Stream', frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cv2.destroyAllWindows()
    sock.close()
    ```
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## 3/ **Фильтр Калмана**

    Фильтр Калмана — это мощный инструмент для отслеживания движущихся объектов, работающий по принципу «предсказание–коррекция». Представьте, что вы следите за летящим мячом и хотите точно знать его положение в каждый момент времени. У вас есть два вида информации: во-первых, модель движения мяча, которая описывает, как он обычно движется под действием силы тяжести, например, по параболической траектории, если нет ветра; во-вторых, измерения положения мяча, полученные с помощью камеры или другого сенсора. Эти измерения не всегда точны и могут содержать ошибки из-за размытия, помех или неточности самого сенсора.

    Работа фильтра Калмана начинается с этапа предсказания. Используя предыдущее известное положение и скорость мяча, а также модель его движения, фильтр предсказывает, где мяч, скорее всего, будет находиться в следующий момент времени. Это предсказание подобно тому, как если бы вы, глядя на траекторию мяча, экстраполировали её вперёд, основываясь на своём понимании физики полёта. Однако вы знаете, что это предсказание неидеально: мяч может немного отклониться от траектории из-за, например, порыва ветра, что и есть неопределённость предсказания.

    Далее наступает этап коррекции. Когда появляется новое измерение фактического положения мяча (например, новый кадр с камеры), фильтр сравнивает его с предсказанным положением (рис. А). Важно, что фильтр не заменяет предсказание новым измерением, а, скорее, уточняет его, учитывая точность как предсказания, так и измерения. Чем точнее измерение (например, если изображение с камеры чёткое), тем сильнее фильтр скорректирует предсказанное положение в сторону фактического положения мяча.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""![](public\image_kalman.png)""")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    На (рис. Б) видно, при размытии мяча в результате плохого кадра (или смазывания движением) фильтр Калмана делает менее точную корректировку.

    После этого этапа коррекции, фильтр Калмана обновляет своё представление о состоянии мяча, включая его положение и скорость. Это обновлённое состояние затем используется для следующего предсказания, и процесс повторяется итеративно. Таким образом, фильтр постоянно отслеживает движение мяча в режиме реального времени, уточняя своё понимание его положения на каждом шаге. Этот итеративный процесс позволяет ему более точно следить за траекторией мяча, даже если его движение не совсем идеально предсказуемо.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Отметим, что в контексте движения мяча, *шум* — это неточности и колебания в измерениях его положения и скорости, возникающие из-за несовершенства камеры, помех или других факторов, которые фильтр Калмана помогает уменьшить для более точного отслеживания.

    При отслеживании мяча в видеостриме фильтр Калмана обычно выполняет свои вычисления на каждом кадре, проходя итерацию предсказания и коррекции. Однако точность и стабильность отслеживания не являются константами и зависят от целого ряда факторов. Частота кадров видео напрямую влияет на то, как часто фильтр обновляет информацию о мяче.

    *Чем выше частота кадров, тем чаще происходят итерации, и тем более плавной и точной может быть траектория отслеживания.*

    Но при этом более высокая частота кадров может потребовать больших вычислительных ресурсов.

    Другим важным фактором является разрешение изображения.

    *Чем выше разрешение, тем более точно фильтр может определить положение мяча на каждом кадре, что уменьшает влияние шума в измерениях.*

    Если мяч мал относительно размера кадра, низкое разрешение может привести к тому, что его положение будет определяться с меньшей точностью, что, в свою очередь, может снизить точность работы фильтра Калмана.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Уровень шума также играет значительную роль. Мы уже говорили о том, что шум может возникать из-за несовершенства камеры, размытия движения или случайных помех.

    *Чем выше уровень шума, тем сложнее фильтру Калмана точно определить положение мяча.*

    В условиях высокого шума, фильтр может быть менее уверен в измерениях и сильнее полагаться на предсказания на основе модели движения, что может сглаживать, но и немного «запаздывать» за реальным движением.

    Помимо этого, качество модели движения оказывает большое влияние на результат работы фильтра. Если модель движения мяча не соответствует реальной траектории, то даже при низком уровне шума и высоком разрешении фильтр не сможет точно отслеживать мяч. Точность модели движения определяет, насколько хорошо фильтр сможет предсказывать положение мяча между кадрами. Также качество оптики и условия освещения будут влиять на чёткость изображения и точность измерений, что в конечном итоге также повлияет на работу фильтра.

    Таким образом, работа фильтра Калмана — это не просто применение алгоритма на каждом кадре, это сложный процесс, на который влияют как характеристики видео (частота кадров, разрешение), так и качество измерений (уровень шума) и даже точность модели движения объекта. Эффективное отслеживание требует оптимального баланса между всеми этими факторами.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ### 3.1/ **Математическая модель фильтра Калмана для отслеживания**

    #### Представление состояния объекта (мяча)

    Состояние мяча в момент времени $k$ описывается вектором состояния ($x_k$). Этот вектор содержит всю информацию, которая нам нужна для отслеживания мяча. Обычно это:

    - **положение мяча**: $p_k = [x_k, y_k]$ (координаты $x$ и $y$ центра мяча);
    - **скорость мяча**: $v_k = [vx_k, vy_k]$ (скорость по $x$ и $y$). То есть $vx_k$ показывает, насколько быстро мяч движется вправо (если положительное значение) или влево (если отрицательное значение), а $vy_k$ показывает, насколько быстро мяч движется вверх (отрицательное значение) или вниз (положительное значение).

    Вместе эти компоненты описывают направление и величину скорости мяча в двумерном пространстве.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Таким образом, вектор состояния может быть представлен как

    $$
    x_k = [x_k, y_k, vx_k, vy_k].
    $$

    Вместе с вектором состояния фильтр Калмана также хранит матрицу ковариации ($P_k$). Эта матрица описывает неопределённость в нашем знании о состоянии мяча. Чем больше ковариация, тем больше неопределённость.

    Матрица ковариации ошибок состояния ($P_k$) — это математический способ представления этой неопределённости. Она не просто показывает, насколько мы «не уверены» в положении или скорости мяча; она показывает, как именно эта неопределённость распределена между разными компонентами вектора состояния.

    $P_k$ — это матрица, а не просто одно число, в ней неопределённость может существовать для разных компонентов вектора состояния (например, координаты $x$, координаты $y$, скорость по $x$, скорость по $y$), и эти неопределённости могут быть связаны друг с другом.

    Если вектор состояния имеет 4 компонента (как в нашем примере $x_k = [x_k, y_k, vx_k, vy_k]$), то $P_k$ будет матрицей размером 4×4:

    $$
    P_k =
    \begin{bmatrix}
    P_k(x_k, x_k) & P_k(x_k, y_k) & P_k(x_k, vx_k) & P_k(x_k, vy_k) \\
    P_k(y_k, x_k) & P_k(y_k, y_k) & P_k(y_k, vx_k) & P_k(y_k, vy_k) \\
    P_k(vx_k, x_k) & P_k(vx_k, y_k) & P_k(vx_k, vx_k) & P_k(vx_k, vy_k) \\
    P_k(vy_k, x_k) & P_k(vy_k, y_k) & P_k(vy_k, vx_k) & P_k(vy_k, vy_k)
    \end{bmatrix}
    $$
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Диагональные элементы матрицы $P_k$ представляют дисперсию (квадрат среднеквадратичного отклонения) для каждого компонента вектора состояния:

    - $P_k(x_k, x_k)$ — дисперсия положения по оси $x$;
    - $P_k(y_k, y_k)$ — дисперсия положения по оси $y$;
    - $P_k(vx_k, vx_k)$ — дисперсия скорости по оси $x$;
    - $P_k(vy_k, vy_k)$ — дисперсия скорости по оси $y$.

    Чем больше значение дисперсии для какого-либо компонента, тем больше неопределённость в нашем знании этого компонента. Например, если $P_k(x_k, x_k)$ большое, это означает, что мы не очень уверены в том, где находится мяч по оси $x$.

    **Недиагональные элементы** матрицы $P_k$ представляют ковариацию между разными компонентами вектора состояния.

    Ковариация показывает, насколько сильно связаны неопределённости двух разных компонентов. Например, может быть ситуация: если мы думаем, что мяч находится правее, то мы также можем думать, что его скорость вправо тоже больше.

    - **Положительная ковариация** означает, что неопределённости двух компонентов изменяются в одном направлении (если мы считаем, что значение одной компоненты больше, то и другой тоже).
    - **Отрицательная ковариация** означает, что неопределённости двух компонентов изменяются в противоположных направлениях.
    - **Нулевая ковариация** означает, что неопределённости двух компонентов не связаны друг с другом.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ### Уравнения предсказания

    Уравнения предсказания используются для оценки состояния мяча в следующий момент времени $(k+1)$ на основе текущего состояния $(k)$ и модели его движения.

    #### **Предсказанное состояние**

    $$
    \hat{x}_{k+1|k} = F \cdot x_k,
    $$

    где $\hat{x}_{k+1|k}$ — это предсказанное состояние мяча в момент времени $k+1$, на основе данных в момент времени $k$;

    $F$ — это матрица перехода состояния, которая описывает, как состояние мяча меняется со временем. Эта матрица основана на модели движения мяча (например, движение с постоянной скоростью, параболическая траектория). Если предположить, что скорость мяча постоянна, то матрица перехода состояния будет иметь вид:

    $$
    F =
    \begin{bmatrix}
    1 & 0 & \Delta t & 0 \\
    0 & 1 & 0 & \Delta t \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
    \end{bmatrix},
    $$

    где $\Delta t$ — это интервал времени между кадрами.

    #### **Предсказанная матрица ковариации ошибки состояния**

    $$
    \hat{P}_{k+1|k} = F \cdot P_k \cdot F^T + Q,
    $$

    где $\hat{P}_{k+1|k}$ — это предсказанная матрица ковариации ошибки состояния на момент времени $k+1$;

    $Q$ — это матрица ковариации шума процесса, которая учитывает неопределённость в модели движения мяча (например, порывы ветра).
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ### Уравнения коррекции

    Уравнения коррекции используют измерения положения мяча, полученные с камеры, для улучшения нашей оценки состояния мяча.

    #### **Инновация**

    $$
    \hat{y}_{k+1} = z_{k+1} - H \cdot \hat{x}_{k+1|k},
    $$

    где:
    - $\hat{y}_{k+1}$ — это инновация, разница между фактическим измерением $z_{k+1}$ (положение мяча на камере) и предсказанным измерением $H \cdot \hat{x}_{k+1|k}$;
    - $z_{k+1}$ — это вектор измерения, содержащий координаты мяча, полученные с камеры (например, $z_{k+1} = [x\_измер, y\_измер]$);
    - $H$ — это матрица наблюдения, которая связывает состояние мяча с тем, что мы можем измерить. В большинстве случаев мы можем измерить только положение мяча, поэтому эта матрица имеет вид:

    $$
    H =
    \begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0
    \end{bmatrix}.
    $$

    #### **Матрица ковариации инновации:**

    $$
    S_{k+1} = H \cdot \hat{P}_{k+1|k} \cdot H^T + R,
    $$

    где:
    - $S_{k+1}$ — это матрица ковариации инновации;
    - $R$ — это матрица ковариации шума измерения, которая учитывает неопределённость в измерениях положения мяча.

    #### **Коэффициент Калмана:**

    $$
    K_{k+1} = \hat{P}_{k+1|k} \cdot H^T S_{k+1}^{-1},
    $$

    где $K_{k+1}$ — это коэффициент Калмана, который определяет, насколько сильно мы должны доверять измерениям по сравнению с предсказанием.

    #### **Обновлённое состояние**

    $$
    x_{k+1} = \hat{x}_{k+1|k} + K_{k+1} \tilde{y}_{k+1},
    $$

    где $x_{k+1}$ — это обновлённое состояние мяча в момент времени $k+1$, учитывающее как предсказание, так и измерение.


    #### **Обновлённая матрица ковариации ошибки состояния:**

    $$
    P_{k+1} = (I - K_{k+1} \cdot H) \hat{P}_{k+1|k},
    $$

    где $P_{k+1}$ — обновлённая матрица ковариации ошибки состояния на момент времени $k+1$.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Таким образом, общая схема работы фильтра Калмана выглядит так:

    1. **Предсказание**: на основе текущего состояния и модели движения мы предсказываем состояние мяча на следующем шаге $(\hat{x}_{k+1|k}, \hat{P}_{k+1|k})$.

    2. **Измерение**: получаем измерение положения мяча с камеры $(z_{k+1})$.

    3. **Коррекция**: используя измерение, мы корректируем предсказанное состояние, получая обновлённую оценку состояния $(x_{k+1}, P_{k+1})$.

    4. **Повтор**: процесс повторяется для следующего кадра.

    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""Хотя явное использование фильтра Калмана не всегда очевидно в трекерах (о которых речь пойдёт в следующем разделе) OpenCV, многие из них, особенно более современные, используют его (или его аналоги) для улучшения стабильности и точности отслеживания. CSRT является явным примером такого использования, но KCF, MIL, TLD и другие трекеры могут также использовать фильтр Калмана или похожие методы для повышения своей эффективности.""")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ### 3.1/ **Практическое применение фильтра Калмана**

    Также в данном примере будет реализована более надежная структура захвата видеопотока с камеры, включающая проверку успешности считывания каждого кадра. Аналогичный подход к проверке на ошибки будет применен и к другим ключевым операциям в коде. В дальнейшем настоятельно рекомендуется придерживаться подобной структуры обработки ошибок для обеспечения стабильности и корректной работы программ.

    Итак, рассмотрим подробно код, который реализует отслеживание объекта в видеопотоке с камеры, используя фильтр Калмана для предсказания и коррекции его положения, и отображает результаты: зеленый квадрат отмечает обнаруженную область объекта, а синий круг указывает на предсказанное фильтром положение центра объекта.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ```python
    import numpy as np
    import cv2

    # Параметры фильтра Калмана (можно настраивать)
    dt = 1 / 30  # Интервал времени (предположим, 30 кадров в секунду)
    state_dim = 4  # x, y, vx, vy
    measurement_dim = 2  # x, y
    # Матрица перехода состояния (F)
    F = np.array([[1, 0, dt, 0],
                  [0, 1, 0, dt],
                  [0, 0, 1, 0],
                  [0, 0, 0, 1]], dtype=np.float32)

    # Матрица наблюдения (H)
    H = np.array([[1, 0, 0, 0],
                  [0, 1, 0, 0]], dtype=np.float32)

    # Матрица ковариации шума процесса (Q)
    Q = np.array([[0.1, 0, 0, 0],
                  [0, 0.1, 0, 0],
                  [0, 0, 0.01, 0],
                  [0, 0, 0, 0.01]], dtype=np.float32)

    # Матрица ковариации шума измерения (R)
    R = np.array([[10, 0],
                  [0, 10]], dtype=np.float32)

    def initialize_kalman(initial_measurement):
        kalman = cv2.KalmanFilter(state_dim, measurement_dim, 0)  # Создадим фильтр
        kalman.transitionMatrix = F  # Задаем матрицу перехода
        kalman.measurementMatrix = H  # Задаем матрицу наблюдения
        kalman.processNoiseCov = Q  # Задаем матрицу ковариации шума процесса
        kalman.measurementNoiseCov = R  # Задаем матрицу ковариации шума измерений
        # Инициализируем состояние фильтра, предполагая начальную скорость 0
        kalman.statePre = np.array([[initial_measurement[0]], [initial_measurement[1]], [0], [0]], dtype=np.float32)
        return kalman

    # Инициализация захвата видео
    cap = cv2.VideoCapture(0)  # Открыть камеру
    if not cap.isOpened():
        print("Не удалось открыть камеру")
        exit()

    ret, frame = cap.read()  # Первый кадр
    if not ret:
        print("Не удалось получить первый кадр")
        cap.release()
        exit()
    # Выделение области для отслеживания
    bbox = cv2.selectROI(frame, False)
    if bbox == (0, 0, 0, 0):
        print("Отслеживание отменено")
        cap.release()
        exit()

    center_x = bbox[0] + bbox[2] // 2
    center_y = bbox[1] + bbox[3] // 2
    initial_measurement = (center_x, center_y)
    kalman = initialize_kalman(initial_measurement)

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # Предсказание положения объекта
        kalman.predict()
        # Получение текущего кадра
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        # Обработка текущего кадра в пределах выделенной области
        x, y, w, h = (int(v) for v in bbox)
        sub_frame = gray[y : y + h, x : x + w]
        # Поиск центра объекта в текущем кадре (локальный поиск)
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(sub_frame)
        measured_x = x + max_loc[0]
        measured_y = y + max_loc[1]
        measurement = np.array([[measured_x], [measured_y]],
                               dtype=np.float32)
        # Коррекция предсказания на основе измерения
        kalman.correct(measurement)
        predicted_center = (int(kalman.statePost[0][0]), int(kalman.statePost[1][0]))
        cv2.rectangle(frame, (bbox[0], bbox[1]), (bbox[0] + bbox[2], bbox[1] + bbox[3]), (0, 255, 0), 2)
        cv2.circle(frame, predicted_center, 4, (255, 0, 0), -1)
        cv2.imshow('Фильтр Калмана', frame)
        # Обновляем прямоугольник отслеживания на основе текущего измерения
        bbox = (measured_x - bbox[2] // 2, measured_y - bbox[3] // 2, bbox[2], bbox[3])

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    cap.release()
    cv2.destroyAllWindows()
    ```
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    /// admonition | ✏️ **ЗАДАНИЕ 1.**
    Разберитесь самостоятельно с принципом работы представленного примера программы. Адаптируйте его под свои условия. Добавьте в код отрисовку траектории движения объекта отслеживания.
    ///
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Форма отчета

    Отчет должен представлять собой программный код для всех заданий и скриншоты экрана, демонстрирующие работоспособоность вашего кода. Отчет загрузить на **moodle**
    """
    )
    return


if __name__ == "__main__":
    app.run()
